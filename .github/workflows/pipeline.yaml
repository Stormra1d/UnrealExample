name: UnrealPipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      build_configuration:
        description: 'Build Configuration'
        required: true
        default: 'Development'
        type: choice
        options: [Development, Shipping, Debug, Test]
      target_platform:
        description: 'Target Platform'
        required: true
        default: 'Win64'
        type: choice
        options: [Win64, Linux]
      enable_tests:
        description: 'Run Tests'
        required: true
        default: true
        type: boolean
      enable_packaging:
        description: 'Package Build'
        required: true
        default: true
        type: boolean
      build_script_path:
        description: 'Override path to Build.xml (optional)'
        required: false
        default: ''
        type: string

env:
  PROJECT_NAME: FPSProject
  UE_VERSION: "5.5"
  UE_ENGINE_PATH: "F:\\UE5.5-Installed"
  BUILD_CONFIGURATION: ${{ github.event.inputs.build_configuration || 'Development' }}
  TARGET_PLATFORM: ${{ github.event.inputs.target_platform || 'Win64' }}

permissions:
  contents: write
  checks: write
  pull-requests: write

jobs:
  build-and-test:
    name: Build, Cook, Package & Test
    runs-on: [self-hosted, windows]
    timeout-minutes: 120

    steps:
      # Checkout
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      # Verify precompiled engine
      - name: Verify Precompiled Engine
        shell: powershell
        run: |
          $UEPath = $env:UE_ENGINE_PATH
          if (!(Test-Path $UEPath)) { Write-Error "Engine not found: $UEPath"; exit 1 }
          if (!(Test-Path "$UEPath\Engine\Build\BatchFiles\RunUAT.bat")) { Write-Error "RunUAT missing"; exit 1 }
          if (!(Test-Path "$UEPath\Engine\Binaries\Win64\UnrealEditor.exe")) { Write-Error "UnrealEditor.exe missing"; exit 1 }
          if (!(Test-Path "$UEPath\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe")) { Write-Error "UnrealBuildTool.exe missing"; exit 1 }

      # Clean Saved and intermediates
      - name: Clean previous build outputs
        shell: powershell
        run: |
          foreach ($d in "Binaries","Intermediate","Saved/StagedBuilds","Saved/Cooked","Saved/Automation","Saved/Logs") {
            if (Test-Path $d) { Remove-Item -Recurse -Force $d -ErrorAction SilentlyContinue }
          }

      # Run BuildGraph (CI)
      - name: Run BuildGraph CI Pipeline
        shell: powershell
        run: |
          $UEPath = $env:UE_ENGINE_PATH
          $RunUAT = Join-Path $UEPath 'Engine\Build\BatchFiles\RunUAT.bat'
          $RepoRoot = $PWD.Path
          if (!(Test-Path $RunUAT)) { Write-Error "RunUAT not found"; exit 1 }

          if (-not $env:PROJECT_ROOT -or -not (Test-Path $env:PROJECT_ROOT)) {
            $uproject = Get-ChildItem -Path $RepoRoot -Filter *.uproject -File -Recurse | Select-Object -First 1
            if (-not $uproject) { Write-Error "No .uproject found"; exit 1 }
            $ProjectRoot = Split-Path -Parent $uproject.FullName
          } else {
            $ProjectRoot = $env:PROJECT_ROOT
          }
          $ProjectName = [IO.Path]::GetFileNameWithoutExtension((Get-ChildItem $ProjectRoot -Filter *.uproject -File).FullName)

          $InputBuildScript = "${{ github.event.inputs.build_script_path }}"

          if ([string]::IsNullOrWhiteSpace($InputBuildScript)) {
            $BuildScript = Join-Path $ProjectRoot 'BuildScripts\Build.xml'
          } else {
            if ([IO.Path]::IsPathRooted($InputBuildScript)) {
              $BuildScript = $InputBuildScript
            } else {
              $BuildScript = Join-Path $RepoRoot $InputBuildScript
            }
          }

          if (!(Test-Path $BuildScript)) {
            Write-Error "Build script not found at: $BuildScript"
            exit 1
          }

          $args = @(
            "BuildGraph",
            "-Script=`"$BuildScript`"",
            "-Target=CI",
            "-set:ProjectName=$ProjectName",
            "-set:ProjectRoot=`"$ProjectRoot`"",
            "-set:BuildConfiguration=$env:BUILD_CONFIGURATION",
            "-set:TargetPlatform=$env:TARGET_PLATFORM",
            "-set:EnableTests=${{ github.event.inputs.enable_tests || 'true' }}",
            "-set:EnablePackage=${{ github.event.inputs.enable_packaging || 'true' }}"
          )
          & $RunUAT @args
          if ($LASTEXITCODE -ne 0) {
            if (Test-Path "Saved\Logs") {
              Get-ChildItem "Saved\Logs" -Filter "*.log" | Sort-Object LastWriteTime -Descending | Select-Object -First 3 | ForEach-Object {
                Write-Host "=== $($_.Name) ==="; Get-Content $_.FullName -Tail 50
              }
            }
            exit $LASTEXITCODE
          }

      - name: Upload Build Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.BUILD_CONFIGURATION }}-${{ env.TARGET_PLATFORM }}
          path: Saved/Logs/**/*
          if-no-files-found: ignore
          retention-days: 7

      - name: Convert Gauntlet JSON to JUnit
        if: always()
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $jsonFiles = Get-ChildItem -Path "Saved\Automation" -Recurse -File -Filter *.json -ErrorAction SilentlyContinue | Where-Object {
            try {
              $j = Get-Content $_.FullName -Raw | ConvertFrom-Json
              $j.tests -and $j.devices
            } catch { $false }
          }
      
          if (-not $jsonFiles) { Write-Host "No UE JSON reports found."; exit 0 }
      
          $doc = New-Object System.Xml.XmlDocument
          $decl = $doc.CreateXmlDeclaration("1.0","UTF-8",$null); $doc.AppendChild($decl) | Out-Null
          $suites = $doc.CreateElement('testsuites'); $doc.AppendChild($suites) | Out-Null
      
          foreach ($f in $jsonFiles) {
            $j = Get-Content $f.FullName -Raw | ConvertFrom-Json
            $suite = $doc.CreateElement('testsuite')
            $relPath = Resolve-Path $f.FullName
            $relPath = $relPath.Path.Substring($PWD.Path.Length).TrimStart('\','/')
            $relDir  = Split-Path $relPath -Parent -Resolve:$false
            $relDir  = $relDir -replace '^[\\\/]',''
            if ([string]::IsNullOrWhiteSpace($relDir)) { $relDir = 'Root' }
            
            $suite.SetAttribute('name', $relDir)
      
            $tests     = @($j.tests)
            $failCnt   = ($tests | Where-Object { $_.state -in @('Fail','Failed') -or $_.errors -gt 0 }).Count
            $skipCnt   = ($tests | Where-Object { $_.state -in @('Skipped','NotRun') }).Count
            $timeSum   = [Math]::Round( ($tests | Measure-Object -Property duration -Sum).Sum, 3 )
      
            $suite.SetAttribute('tests',    [string]$tests.Count)
            $suite.SetAttribute('failures', [string]$failCnt)
            $suite.SetAttribute('skipped',  [string]$skipCnt)
            $suite.SetAttribute('time',     [string]$timeSum)
      
            foreach ($t in $tests) {
              $case = $doc.CreateElement('testcase')
              $nsParts = $t.fullTestPath -split '\.'
              $class   = if ($nsParts.Length -gt 1) { ($nsParts[0..($nsParts.Length-2)] -join '.') } else { 'UE.Automation' }
              $case.SetAttribute('classname', $class)
              $case.SetAttribute('name',      "$($t.testDisplayName)")
              $case.SetAttribute('time',      ([string]([Math]::Round([double]$t.duration,3))))
      
              if ($t.state -in @('Skipped','NotRun')) {
                $case.AppendChild($doc.CreateElement('skipped')) | Out-Null
              } elseif ($t.state -ne 'Success' -or [int]$t.errors -gt 0) {
                $fail = $doc.CreateElement('failure')
                $fail.SetAttribute('message', "State=$($t.state); Errors=$($t.errors); Warnings=$($t.warnings)")
                $case.AppendChild($fail) | Out-Null
              }
              $suite.AppendChild($case) | Out-Null
            }
            $suites.AppendChild($suite) | Out-Null
          }
      
          $outDir = "Saved\Automation\JUnit"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          $out = Join-Path $outDir "gauntlet.junit.xml"
          $doc.Save($out)
          Write-Host "JUnit written: $out"
      
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ env.BUILD_CONFIGURATION }}-${{ env.TARGET_PLATFORM }}
          path: Saved/Automation/**/*
          if-no-files-found: ignore
          retention-days: 14
      
      - name: Upload Packaged Build
        if: success() && (github.event.inputs.enable_packaging == 'true' || github.event.inputs.enable_packaging == null)
        uses: actions/upload-artifact@v4
        with:
          name: packaged-build-${{ env.BUILD_CONFIGURATION }}-${{ env.TARGET_PLATFORM }}
          path: Saved/StagedBuilds/**/*
          if-no-files-found: ignore
          retention-days: 30

      - name: Publish Test Results
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Unreal Automation Tests
          path: Saved/Automation/JUnit/**/*.xml
          reporter: java-junit
          fail-on-error: false
          fail-on-empty: true

      - name: Generate workflow summary
        if: always()
        shell: powershell
        run: |
          $s = $env:GITHUB_STEP_SUMMARY
          "## CI Summary ($env:BUILD_CONFIGURATION / $env:TARGET_PLATFORM)" | Out-File $s -Encoding utf8
      
          $xmlCount = (Get-ChildItem -Path "Saved\Automation\JUnit" -Recurse -Filter *.xml -ErrorAction SilentlyContinue | Measure-Object).Count
          "JUnit XML files: $xmlCount" | Out-File $s -Append -Encoding utf8
      
          $jsonFiles = Get-ChildItem -Path "Saved\Automation" -Recurse -File -Filter *.json -ErrorAction SilentlyContinue
          if ($jsonFiles) {
            $all = @()
            foreach ($f in $jsonFiles) {
              try {
                $j = Get-Content $f.FullName -Raw | ConvertFrom-Json
                if ($j.tests) { $all += $j }
              } catch { }
            }
            if ($all.Count -gt 0) {
              $tests   = @($all | ForEach-Object { $_.tests } | Where-Object { $_ })
              $passed  = ($tests | Where-Object { $_.state -eq 'Success' }).Count
              $failed  = ($tests | Where-Object { $_.state -in @('Fail','Failed') -or $_.errors -gt 0 }).Count
              $skipped = ($tests | Where-Object { $_.state -in @('Skipped','NotRun') }).Count
              $dur     = [Math]::Round( ($tests | Measure-Object -Property duration -Sum).Sum, 2 )
      
              "`n### UE Automation Results" | Out-File $s -Append -Encoding utf8
              "| Metric | Value |"                          | Out-File $s -Append -Encoding utf8
              "|---|---:|"                                  | Out-File $s -Append -Encoding utf8
              "| Total tests | $($tests.Count) |"           | Out-File $s -Append -Encoding utf8
              "| Passed | $passed |"                        | Out-File $s -Append -Encoding utf8
              "| Failed | $failed |"                        | Out-File $s -Append -Encoding utf8
              "| Skipped | $skipped |"                      | Out-File $s -Append -Encoding utf8
              "| Duration (s) | $dur |"                     | Out-File $s -Append -Encoding utf8
      
              $failedTests = $tests | Where-Object { $_.state -in @('Fail','Failed') -or $_.errors -gt 0 } | Select-Object -First 20
              if ($failedTests) {
                "`n<details><summary>First 20 failing tests</summary>" | Out-File $s -Append -Encoding utf8
                "| Test | State | Errors | Warnings | Time(s) |" | Out-File $s -Append -Encoding utf8
                "|---|---|---:|---:|---:|" | Out-File $s -Append -Encoding utf8
                foreach ($t in $failedTests) {
                  $line = "| $($t.fullTestPath) | $($t.state) | $($t.errors) | $($t.warnings) | $([Math]::Round($t.duration,3)) |"
                  $line | Out-File $s -Append -Encoding utf8
                }
                "</details>" | Out-File $s -Append -Encoding utf8
              }
            }
          }
      
          $auto = Join-Path $PWD 'PerformanceTestResults_Automation.csv'
          if (-not (Test-Path $auto)) {
            $auto = Get-ChildItem -Path (Join-Path $PWD 'Saved\Automation\Performance') -Filter *.csv -Recurse -ErrorAction SilentlyContinue |
                    Sort-Object LastWriteTime -Descending | Select-Object -ExpandProperty FullName -First 1
          }
          
          if ($auto -and (Test-Path $auto)) {
            "`n### Performance CSV (first 10 rows)`n" | Out-File $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            $rows = Import-Csv -Path $auto
            if ($rows.Count -gt 0) {
              $cols = $rows[0].PSObject.Properties.Name
          
              # Header
              "| " + ($cols -join " | ") + " |" | Out-File $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              "| " + (($cols | ForEach-Object { '---' }) -join " | ") + " |" | Out-File $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          
              # Rows
              $rows | Select-Object -First 10 | ForEach-Object {
                $row = $_
                $vals = $cols | ForEach-Object { $row.$_ }
                "| " + ($vals -join " | ") + " |" | Out-File $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              }
            }
          } else {
            "`n_No performance CSV found in project root or Saved/Automation/Performance._" | Out-File $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          }

      - name: Zip Packaged Build (for release asset)
        if: success() && (github.event.inputs.enable_packaging == 'true' || github.event.inputs.enable_packaging == null)
        shell: powershell
        run: |
          $src = Join-Path $PWD "Saved\StagedBuilds\${{ env.TARGET_PLATFORM }}"
          if (Test-Path $src) {
            $zip = "packaged-${{ env.BUILD_CONFIGURATION }}-${{ env.TARGET_PLATFORM }}.zip"
            if (Test-Path $zip) { Remove-Item $zip -Force }
            Compress-Archive -Path (Join-Path $src '*') -DestinationPath $zip -Force
            Write-Host "Created $zip"
          } else {
            Write-Host "No packaged build found at $src"
          }

      # Create Release
      - name: Create GitHub Release
        if: success() && github.ref == 'refs/heads/main' && (github.event.inputs.enable_packaging == 'true' || github.event.inputs.enable_packaging == null)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: build-${{ github.run_number }}
          name: Build ${{ github.run_number }}
          body: |
            Automated build from commit ${{ github.sha }}
      
            Configuration: ${{ env.BUILD_CONFIGURATION }}
            Platform: ${{ env.TARGET_PLATFORM }}
          prerelease: ${{ env.BUILD_CONFIGURATION != 'Shipping' }}
          draft: false
          files: packaged-${{ env.BUILD_CONFIGURATION }}-${{ env.TARGET_PLATFORM }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  static-analysis:
    name: Static Code Analysis
    runs-on: [self-hosted, windows]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Verify Precompiled Engine
        shell: powershell
        run: |
          $UEPath = $env:UE_ENGINE_PATH
          if (!(Test-Path "$UEPath\Engine\Build\BatchFiles\RunUAT.bat")) { Write-Error "Engine not found"; exit 1 }

      - name: Run BuildGraph Analysis Only
        shell: powershell
        run: |
          $UEPath = $env:UE_ENGINE_PATH
          $RunUATPath = "$UEPath\Engine\Build\BatchFiles\RunUAT.bat"
          $ProjectRoot = $PWD.Path
          & $RunUATPath BuildGraph `
            -Script="$ProjectRoot\BuildScripts\Build.xml" `
            -Target=Analyze `
            -set:ProjectName=$env:PROJECT_NAME `
            -set:ProjectRoot="$ProjectRoot" `
            -set:BuildConfiguration=$env:BUILD_CONFIGURATION `

      - name: Upload Analysis Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: static-analysis-results
          path: Saved/Logs/**/*StaticAnalysis*
          if-no-files-found: ignore
          retention-days: 7
